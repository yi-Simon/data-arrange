### 1.防抖和节流

#### 事件快速重复触发 影响性能，导致页面卡顿

    节流：事件在固定时间内只能触发一次 lodash的throttle方法
      设定一个flag锁，设置定时器，回调函数解锁，定时器之后锁住
      延时结束调用回调之前都是锁定状态，无法再绑定新定时器直到解锁

    防抖：停止触发后一定事件后才会触发 lodash的debounce方法
      在设置定时器之前重置定时器，如果连续触发，
      定时器就会一直重置效果就会是只有最后一次(延迟时间内)能够触发

### 2.事件委派

#### 块级元素内部的行内元素在被点击时不会触发

​

### 3.拖拽功能 DIV

    设置鼠标按住标记和鼠标坐标对象
      鼠标按下时记录鼠标位置
    鼠标滑动时，如果鼠标是按住的，那么就获取鼠标位置，
      此时的鼠标坐标减去鼠标按下的坐标就是鼠标滑动的距离
    让div此时的定位坐标加上鼠标滑动距离就是div的最终坐标
      鼠标抬起后，清除标记

### 4.深拷贝

    使用Object.prototype.toString.call()来获取数据类型
    首先定义数据子元素的容器，检测数据的类型
      确定对象和数组的容器类型，其他数据类型直接返回这个数据
    遍历子元素
      如果是函数使用data[i].bind(container)拷贝到容器
      如果是对象/数组则将这个数据递归拷贝的结果放入容器
      如果是其他数据(基本数据类型)，直接放入容器
    将最终容器返回

### 5.instanceof 原理

    定义一个proto保存左边变量的__proto__
    创建一个while循环，判断保存的proto
    如果右边变量的原型在左边变量的原型链上，也就是说，如果在
    proto或者proto=proto.__proto上，如果找到了(proto===right.prototype)
    如果没有找到，那么就return false

### 6.new 原理

传入：构造函数，参数
如果传入的不是构造函数，返回
使用构造函数的原型为原型创建一个对象 Object.create()
在创建的新对象中执行构造函数 apply
判断执行的结果，如果是对象就返回这个结果
否则返回新对象

### 7.this

> this 指向调用它的对象，如果是严格模式则指向 undefined
>
> 自定义 call

    自定义Function.prototype.mycall
    传入执行对象，参数
    定义一个symbol
